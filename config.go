package sc

import (
	"time"
)

// CacheOption represents a single cache option.
// See other package-level functions which return CacheOption for more details.
type CacheOption func(c *cacheConfig)

type cacheConfig struct {
	enableStrictCoalescing bool
	backend                cacheBackendType
	capacity               int
	cleanupInterval        time.Duration
}

type cacheBackendType int

const (
	cacheBackendMap cacheBackendType = iota
	cacheBackendLRU
	cacheBackend2Q
)

func defaultConfig() cacheConfig {
	return cacheConfig{
		enableStrictCoalescing: false,
		backend:                cacheBackendMap,
		capacity:               0,
		cleanupInterval:        0,
	}
}

// WithMapBackend specifies to use the built-in map for storing cache items (the default).
// Note that the default map backend will not evict old cache items. If your key's cardinality is high, consider using
// other backends such as LRU.
// Initial capacity needs to be non-negative.
func WithMapBackend(initialCapacity int) CacheOption {
	return func(c *cacheConfig) {
		c.backend = cacheBackendMap
		c.capacity = initialCapacity
	}
}

// WithLRUBackend specifies to use LRU for storing cache items.
// Capacity needs to be greater than 0.
func WithLRUBackend(capacity int) CacheOption {
	return func(c *cacheConfig) {
		c.backend = cacheBackendLRU
		c.capacity = capacity
	}
}

// With2QBackend specifies to use 2Q cache for storing cache items.
// Capacity needs to be greater than 0.
func With2QBackend(capacity int) CacheOption {
	return func(c *cacheConfig) {
		c.backend = cacheBackend2Q
		c.capacity = capacity
	}
}

// EnableStrictCoalescing enables strict coalescing check with a slight overhead. The check prevents Get calls
// coming later in time to be coalesced with already stale response generated by a Get call earlier in time.
// This is similar to the behavior of 'automatically calling' Cache.Forget after a value is expired, but different in
// that it does not initiate a new request until the current one finishes or Cache.Forget is called.
//
// This is a generalization of so-called 'zero-time-cache', where the original zero-time-cache behavior is
// achievable with zero freshFor/ttl values.
// see also: https://qiita.com/methane/items/27ccaee5b989fb5fca72 (ja)
//
// This is only useful if you need to make sure that no Get calls are served expired values due to coalescing.
// Most users should not need this behavior.
func EnableStrictCoalescing() CacheOption {
	return func(c *cacheConfig) {
		c.enableStrictCoalescing = true
	}
}

// WithCleanupInterval specifies cleanup interval of expired items.
//
// Note that by default, a cache will be initialized without a cleaner.
// Try tuning your cache size (and using non-map backend) before using this option.
// Using cleanup interval on a cache with many items may decrease the through-put,
// since the cleaner has to acquire the lock to iterate through all items.
func WithCleanupInterval(interval time.Duration) CacheOption {
	return func(c *cacheConfig) {
		c.cleanupInterval = interval
	}
}
